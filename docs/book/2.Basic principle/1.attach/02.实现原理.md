# 实现原理

> 2023-07-17 第1版

> 2023-07-27 第2版

> 2023-08-03 第3版

在上一节介绍了attach api的基本使用，本节将结合jdk源代码详细介绍其中的原理。
attach机制本质上是进程间的通信，外部进程通过JVM提供的socket连接到目标JVM上并发送指令，JVM接受并处理指令然后返回处理结果。
可能会比较奇怪，attach时并没有发现JVM创建socket端口，其实JVM使用了UDS。

## attach 客户端源码解析

有了上面的使用基础，我们将分析attach api的实现原理并对相应的源码做分析，从而挖掘更多可用的功能。
`com.sun.tools.attach.VirtualMachine`是抽象类，
不同厂商的虚拟机可以实现不同VirtualMachine，HotSpotVirtualMachine是HotSpot官方提供的VirtualMachine实现，
它是一个抽象类，在不同操作系统上都有各自实现，如 macos系统上的实现为`VirtualMachineImpl`。

先来看下`HotSpotVirtualMachine`抽象类的loadAgentLibrary方法
```java
private void loadAgentLibrary(String agentLibrary, boolean isAbsolute, String options)
    throws AgentLoadException, AgentInitializationException, IOException
{
    if (agentLibrary == null) {
        throw new NullPointerException("agentLibrary cannot be null");
    }
    // 注意
    // jdk8及一下返回 0
    // jdk9 及以上返回 return code: 0
    String msgPrefix = "return code: ";
    // 执行load指令，给目标 jvm 传输 agent jar路径和参数
    InputStream in = execute("load",
                             agentLibrary,
                             isAbsolute ? "true" : "false",
                             options);
    try (BufferedReader reader = new BufferedReader(new InputStreamReader(in))) {
        String result = reader.readLine();
        // 返回结果
        if (result == null) {
            throw new AgentLoadException("Target VM did not respond");
        } else if (result.startsWith(msgPrefix)) {
            int retCode = Integer.parseInt(result.substring(msgPrefix.length()));
            if (retCode != 0) {
                throw new AgentInitializationException("Agent_OnAttach failed", retCode);
            }
        } else {
            throw new AgentLoadException(result);
        }
    }
}
```
上面的代码是加载一个Java Agent，核心实现在 `execute` 方法中，来看下execute方法的源码：
```java
/*
 * Execute the given command in the target VM - specific platform
 * implementation must implement this.
 */
abstract InputStream execute(String cmd, Object ... args)
    throws AgentLoadException, IOException;
```
execute是一个抽象方法，实现在子类中，HotSpotVirtualMachine类中的其他方法大多数最终都会调用这个execute。

再来看下子类`VirtualMachineImpl`：
``` java           
VirtualMachineImpl(AttachProvider provider, String vmid)
    throws AttachNotSupportedException, IOException
{
    super(provider, vmid);

    // This provider only understands pids
    int pid;
    try {
        pid = Integer.parseInt(vmid);
    } catch (NumberFormatException x) {
        throw new AttachNotSupportedException("Invalid process identifier");
    }
    // 在/tmp目录下寻找socket文件是否存在                    
    // Find the socket file. If not found then we attempt to start the
    // attach mechanism in the target VM by sending it a QUIT signal.
    // Then we attempt to find the socket file again.
    File socket_file = new File(tmpdir, ".java_pid" + pid);
    socket_path = socket_file.getPath();
    if (!socket_file.exists()) {
        // 创建 attach_pid 文件
        File f = createAttachFile(pid);
        try {
            // 向目标JVM 发送 kill -3 信号
            sendQuitTo(pid);

            // 等待目标 jvm 创建 socket 文件
            // give the target VM time to start the attach mechanism
            final int delay_step = 100;
            final long timeout = attachTimeout();
            long time_spend = 0;
            long delay = 0;
            do {
                // Increase timeout on each attempt to reduce polling
                delay += delay_step;
                try {
                    Thread.sleep(delay);
                } catch (InterruptedException x) { }

                time_spend += delay;
                if (time_spend > timeout/2 && !socket_file.exists()) {
                    // Send QUIT again to give target VM the last chance to react
                    sendQuitTo(pid);
                }
            } while (time_spend <= timeout && !socket_file.exists());
            
            // 等待时间结束后，确认socket文件是否存在
            if (!socket_file.exists()) {
                throw new AttachNotSupportedException(
                    String.format("Unable to open socket file %s: " +
                                  "target process %d doesn't respond within %dms " +
                                  "or HotSpot VM not loaded", socket_path,
                                  pid, time_spend));
            }
        } finally {
            // 最后删除 attach_pid 文件
            f.delete();
        }
    }

    // Check that the file owner/permission to avoid attaching to
    // bogus process
    // 确认socket文件权限
    checkPermissions(socket_path);

    // Check that we can connect to the process
    // - this ensures we throw the permission denied error now rather than
    // later when we attempt to enqueue a command.
    // 尝试连接socket，确认可以连接到目标JVM
    int s = socket();
    try {
        connect(s, socket_path);
    } finally {
        close(s);
    }
}
```
再次梳理下attach通信的过程：

第一步： 发起attach的进程在/tmp目录下查找目标JVM是否已经创建了的socket文件`.java_pid` ,如果已经创建，直接跳到第六步；

第二步： attach进程创建socket通信的`握手文件`attach_pid文件；

第三步： attach进程给目标JVM发送 kill -3 信号，提示目标JVM外部进程发起了attach请求；

第四步： attach进程等待java_pid文件创建，java_pid文件由目标JVM创建；

第五步： 删除`握手文件`attach_pid文件；

第六步： 校验socket文件权限；

第七步： 测试socket连接可用性；    

上面详细说明了socket连接的建立过程，下面将介绍socket发送命令的过程。
```java
InputStream execute(String cmd, Object ... args) throws AgentLoadException, IOException {
    // 参数、socket_path校验
        
    // create UNIX socket
    int s = socket();

    // connect to target VM
    try {
        connect(s, socket_path);
    } catch (IOException x) {
        // 错误处理
    }

    IOException ioe = null;

    // connected - write request
    // <ver> <cmd> <args...>
    try {
        writeString(s, PROTOCOL_VERSION);
        writeString(s, cmd);

        for (int i=0; i<3; i++) {
            if (i < args.length && args[i] != null) {
                writeString(s, (String)args[i]);
            } else {
                // 没有参数，发送空字符串代替
                writeString(s, "");
            }
        }
    } catch (IOException x) {
        ioe = x;
    }

    // 读取执行结果
    // Create an input stream to read reply
    SocketInputStream sis = new SocketInputStream(s);

    // Read the command completion status
    int completionStatus;
    try {
        completionStatus = readInt(sis);
    } catch (IOException x) {
        // 错误处理
    }

    if (completionStatus != 0) {
        // 错误处理
    }
    
    return sis;
}
```
从上面的代码可以知道一次命令发送，先发送版本协议，然后是命令，最后是参数。

为了更加清晰的看到通信协议，这里使用strace跟踪attach过程。

```shell
strace -f java Main 2> main.out
```

在 main.out 文件中找到attach通信过程，先写入协议号、命令、参数，然后读取返回结果。
```text
[pid 31412] socket(AF_LOCAL, SOCK_STREAM, 0) = 6
[pid 31412] connect(6, {sa_family=AF_LOCAL, sun_path="/tmp/.java_pid27730"}, 110) = 0
[pid 31412] write(6, "1", 1)            = 1
[pid 31412] write(6, "\0", 1)           = 1
[pid 31412] write(6, "properties", 10)  = 10
[pid 31412] write(6, "\0", 1)           = 1
[pid 31412] write(6, "\0", 1 <unfinished ...>
[pid 31412] write(6, "\0", 1)           = 1
[pid 31412] write(6, "\0", 1)           = 1
[pid 31412] read(6, "0", 1)             = 1
[pid 31412] read(6, "\n", 1)            = 1
[pid 31412] read(6, "#Thu Jul 27 17:52:11 CST 2023\nja"..., 128) = 128
[pid 31412] read(6, "oot.loader\nsun.boot.library.path"..., 128) = 128
[pid 31412] read(6, "poration\njava.vendor.url=http\\:/"..., 128) = 128
[pid 31412] read(6, ".pkg=sun.io\nuser.country=CN\nsun."..., 128) = 128
[pid 31412] read(6, "e=Java Virtual Machine Specifica"..., 128) = 128
```

发送协议可以总结为下面的字符串序列
```text
1 byte PROTOCOL_VERSION
1 byte '\0'
n byte command
1 byte '\0'
n byte arg1
1 byte '\0'
n byte arg2
1 byte '\0'
n byte arg3
1 byte '\0'
```
## attach 服务端源码解析

既然已经知道了发起attach的进程的通信原理，我们再来看下接受attach的服务端代码是怎么样，这部分代码是c语言构建，但是也是不难理解的。
以macos系统为例子，说明目标JVM如何处理attach请求和解析attach命令。


