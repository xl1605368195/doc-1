## 10.2 OGNL使用与源码解析


OGNL表达式，即Object-Graph Navigation Language，是一种在Java中使用的功能强大的表达式语言。
它被集成在Mybatis和Struts2等框架中，主要用于访问数据，具有类型转换、访问对象方法、操作集合对象等功能
。OGNL表达式的语法简单且一致，能通过简单的表达式访问对象的任意属性，调用对象的方法，以及遍历对象的结构图等。

首先来介绍下OGNL的三要素：

+ 表达式：

表达式（Expression）是整个OGNL的核心内容，所有的OGNL操作都是针对表达式解析后进行的。
通过表达式来告诉OGNL操作到底要干些什么。因此，表达式其实是一个带有语法含义的字符串，
整个字符串将规定操作的类型和内容。OGNL表达式支持大量的表达式，
如“链式访问对象”、表达式计算、甚至还支持Lambda表达式。

+ Root对象：

OGNL的Root对象可以理解为OGNL的操作对象。当我们指定了一个表达式的时候，
我们需要指定这个表达式针对的是哪个具体的对象。而这个具体的对象就是Root对象，
这就意味着，如果有一个OGNL表达式，那么我们需要针对Root对象来进行OGNL表达式的计算并且返回结果。

+ 上下文环境：

有个Root对象和表达式，我们就可以使用OGNL进行简单的操作了，
如对Root对象的赋值与取值操作。但是，实际上在OGNL的内部，
所有的操作都会在一个特定的数据环境中运行。
这个数据环境就是上下文环境（Context）。OGNL的上下文环境是一个Map结构，
称之为OgnlContext。Root对象也会被添加到上下文环境当中去。

### 10.2.1 基本使用

本节仅介绍其基本用法。

+ 访问对象属性

使用点号（.）来访问对象的属性。例如，person.name 将访问 person 对象的 name 属性

+ 调用方法
  
使用圆括号来调用对象的方法。例如，person.getAge() 将调用 person 对象的 getAge 方法

+ 对Root对象的访问

OGNL使用的是一种链式的风格进行对象的访问。具体代码如下：
```java

```

+ 对上下文对象的访问

使用OGNL的时候如果不设置上下文对象，系统会自动创建一个上下文对象，
如果传入的参数当中包含了上下文对象则会使用传入的上下文对象。
当访问上下文环境当中的参数时候，需要在表达式前面加上'#'，表示了与访问Root对象的区别。
具体代码如下：
```java
// 引用变量person的name属性
#person.name 
```

使用点号（.）来访问对象的属性。例如，person.name 将访问 person 对象的 name 属性


+ 调用构造函数创建对象

可以像在Java中一样使用`new`关键字创建新对象。除了java.lang包中的类之外，其它类必须指定类的完全限定名称。
```java
new java.lang.Integer(100)
// java.lang包下的类，可以省去包名称
new Integer(100)
```

+ 创建集合对象

OGNL支持直接使用表达式来创建集合对象。主要有三种情况：
构造List对象：使用`{}`，中间使用','进行分割，如{"aa", "bb", "cc"}
构造Map对象：使用`#{}`，中间使用','进行分割键值对，键值对使用':'区分，如#{"key1" : "value1", "key2" : "value2"}

```java
// 创建map
#{ "foo" : "foo value", "bar" : "bar value" }
// 创建特定类型的map
#@java.util.LinkedHashMap@{ "foo" : "foo value", "bar" : "bar value" }
```

创建Java数组，例如int[]或Integer[]。
```java
// 创建一个由三个整数1、2和3组成的新int数组。
new int[] { 1, 2, 3 }
// 创建所有元素为null或0的数组
new int[5]
```

+ 集合操作

OGNL 提供了集合选择（selection）和集合投影（projection）操作。例如，  
```
// 将从 people 集合中选择年龄大于 30 的所有对象
people.{? #this.age > 30} 
```
+  对象操作

+ 调用静态方法

使用语法`@class@method(args)`调用静态方法。除了java.lang包中的类之外，其它类必须指定类的完全限定名称。
```java
@java.lang.Integer@valueOf("100")
// java.lang包下的类，可以省去包名称
@Integer@valueOf("100")
```

+ 获取静态字段

与调用静态方法一样，可以使用语法`@class@field`引用静态字段。除了java.lang包中的类之外，其它类必须指定类的完全限定名称。
```java
// 访问System类的out字段
@java.lang.System@out
@java.lang.Integer@TYPE
// java.lang包下的类，可以省去包名称
@Integer@TYPE
```

> 图10-15 Ognl官方文档

![图10-15 Ognl官方文档](../../.vuepress/public/images/book/expression/img/10-15.jpg)

> Ognl官方文档：https://commons.apache.org/dormant/commons-ognl/language-guide.html



### 10.2.2 源码解析

在了解其API的使用之后，应该深入分析其实现原理，这是选取合适Hook类的关键，因此源码分析是十分必要的。
本节将对OGNL表达式语法解析、编译和执行过程做一个Debug（代码以图片的形式展现）。

### 10.2.2.1 表达式词法语法解析
下面的代码执行一个简单的表达式，调用Math类的静态方法random生成一个随机数并乘以100.0，然后获取表达式的值并输出。
> 图10-16 Debug的表达式代码

![图10-16 Debug的表达式代码](../../.vuepress/public/images/book/expression/img/10-16.jpg)

```java
// ognl@3.4.2
public class Main {
    public static void main(String[] args) throws Exception {
        OgnlContext context = (OgnlContext) Ognl.createDefaultContext(null);
        Object result = Ognl.getValue("@java.lang.Math@random()*100", context, context.getRoot());
        System.out.println("value: " + result);
    }
}
```
图10-16中的代码第 7行处实际调用Ognl类中的getValue方法（下图中代码460行处），调用Ognl类中的getValue的重载方法对表达式进行初步处理。
> 图10-17 Ognl.getValue对表达式进行初步处理

![图10-17 Ognl.getValue对表达式进行初步处理](../../.vuepress/public/images/book/expression/img/10-17.jpg)

在图10-17中的代码480处，实际调用了`parseExpression`对表达式的解析，并将解析的返回结果作为getValue方法的入参，
来看下parseExpression对表达式的解析。
> 图10-18 Ognl.parseExpression对表达式的处理

![图10-18 Ognl.parseExpression对表达式的处理](../../.vuepress/public/images/book/expression/img/10-18.jpg)

OgnlParser是一个JavaCC解析器类，它将OGNL表达式转换为抽象语法树（AST），然后可以被getValue和setValue方法获取和设置值。

代码137行处创建了一个OgnlParse对象来解析给定的表达式，并返回能被Ognl方法处理AST语法树，AST语法树的节点数据如下。

代码138行处parser.topLevelExpression方法返回AST语法树的顶层root节点。

> 图10-19 OgnlParser获取的AST语法树

![图10-19 OgnlParser获取的AST语法树](../../.vuepress/public/images/book/expression/img/10-19.jpg)

从图10-19的变量区域可以看出，AST语法树的root节点是一个ASTMultiply类型节点，
root节点下面有2个子节点分别ASTStaticMethod和ASTConst类型节点。

### 10.2.2.2 表达式节点值计算

在获取了表达式的AST语法树之后，开始计算表达式的节点的值。

![图10-20 计算节点Node的值](../../.vuepress/public/images/book/expression/img/10-20.jpg)

这里的Node是一个接口，看下他的子类，

![图10-21 Node接口的子类](../../.vuepress/public/images/book/expression/img/10-21.jpg)

上面代码的第408行处，实际会调用子类的getValue方法计算具体的值。

获取节点的值先调用SimpleNode类的getValue方法。

![图10-22 SimpleNode类的getValue方法](../../.vuepress/public/images/book/expression/img/10-22.jpg)

实际调用evaluateGetValueBody()，来看下这个方法。
![图10-23 SimpleNode类的evaluateGetValueBody方法](../../.vuepress/public/images/book/expression/img/10-23.jpg)

在代码第171行，evaluateGetValueBody()在计算非常量情况的结果时会调用子类的getValueBody。

Ognl在处理节点时分为多种情况进行处理：ASTChain、ASTConst、ASTCtor、ASTInstanceof、ASTList、ASTMethod、ASTStaticField、ASTStaticMethod等。

![图10-23 Node接口的uml](../../.vuepress/public/images/book/expression/img/10-24.jpg)

![图10-23 Node接口的uml](../../.vuepress/public/images/book/expression/img/10-25.jpg)

![图10-23 Node接口的uml](../../.vuepress/public/images/book/expression/img/10-26.jpg)

![图10-23 Node接口的uml](../../.vuepress/public/images/book/expression/img/10-27.jpg)

![图10-23 Node接口的uml](../../.vuepress/public/images/book/expression/img/10-28.jpg)
