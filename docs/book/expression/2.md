## 10.2 OGNL使用与源码解析


OGNL表达式，即Object-Graph Navigation Language，是一种在Java中使用的功能强大的表达式语言。
它被集成在Struts2等框架中，主要用于访问数据，具有类型转换、访问对象方法、操作集合对象等功能
。OGNL表达式的语法简单且一致，能通过简单的表达式访问对象的任意属性，调用对象的方法，以及遍历对象的结构图等。
例如，对于一个对象结构如user1.person.address.province，OGNL表达式可以轻松访问到这个深层嵌套的属性。

首先来介绍下OGNL的三要素：

+ 表达式：

表达式（Expression）是整个OGNL的核心内容，所有的OGNL操作都是针对表达式解析后进行的。
通过表达式来告诉OGNL操作到底要干些什么。因此，表达式其实是一个带有语法含义的字符串，
整个字符串将规定操作的类型和内容。OGNL表达式支持大量的表达式，
如“链式访问对象”、表达式计算、甚至还支持Lambda表达式。

+ Root对象：

OGNL的Root对象可以理解为OGNL的操作对象。当我们指定了一个表达式的时候，
我们需要指定这个表达式针对的是哪个具体的对象。而这个具体的对象就是Root对象，
这就意味着，如果有一个OGNL表达式，那么我们需要针对Root对象来进行OGNL表达式的计算并且返回结果。

+ 上下文环境：

有个Root对象和表达式，我们就可以使用OGNL进行简单的操作了，
如对Root对象的赋值与取值操作。但是，实际上在OGNL的内部，
所有的操作都会在一个特定的数据环境中运行。
这个数据环境就是上下文环境（Context）。OGNL的上下文环境是一个Map结构，
称之为OgnlContext。Root对象也会被添加到上下文环境当中去。

### 10.2.1 基本使用

本节仅介绍其基本用法。

> https://www.cnblogs.com/yw-ah/p/5760192.html

+ 对Root对象的访问

OGNL使用的是一种链式的风格进行对象的访问。具体代码如下：
```java
User user = new User("rcx", "123");
Address address = new Address("110003", "沈阳市和平区");
user.setAddress(address);

System.out.println(Ognl.getValue("name", user)); // rcx
System.out.println(Ognl.getValue("address", user));  // com.rcx.ognl.Address@dda25b
System.out.println(Ognl.getValue("address.port", user)); // 110003
```

+ 对上下文对象的访问

使用OGNL的时候如果不设置上下文对象，系统会自动创建一个上下文对象，
如果传入的参数当中包含了上下文对象则会使用传入的上下文对象。
当访问上下文环境当中的参数时候，需要在表达式前面加上'#'，表示了与访问Root对象的区别。
具体代码如下：
```java
User user = new User("rcx", "123");
Address address = new Address("110003", "沈阳市和平区");
user.setAddress(address);
Map<String, Object> context = new HashMap<String, Object>();
context.put("init", "hello");
context.put("user", user);

System.out.println(Ognl.getValue("#init", context, user));
System.out.println(Ognl.getValue("#user.name", context, user));
System.out.println(Ognl.getValue("name", context, user));
```
这段代码很好的区分了访问Root对象和访问上下文对象的区别。

+ 对静态变量的访问

在OGNL表达式当中也可以访问静态变量或者调用静态方法，格式如@[class]@[field/method()]。具体代码如下：
```java
Object object = Ognl.getValue("@com.rcx.ognl.Constant@ONE", null);
            
Object object1 = Ognl.getValue("@com.rcx.ognl.Constant@get()", null);
            
Object object2 = Ognl.getValue("@com.rcx.ognl.Constant@getString()", null);
            
System.out.println(object);
System.out.println(object1);
System.out.println(object2);
```

+ 对数组和集合的访问
```java

```

+ 创建对象

OGNL支持直接使用表达式来创建对象。主要有三种情况：
构造List对象：使用{},中间使用','进行分割如{"aa", "bb", "cc"}
构造Map对象：使用#{}，中间使用',进行分割键值对，键值对使用':'区分，如#{"key1" : "value1", "key2" : "value2"}
构造任意对象：直接使用已知的对象的构造方法进行构造。
要创建对象列表，请将表达式列表放在大括号中。与方法参数一样，这些表达式不能使用逗号运算符，除非它被括在括号中。以下是一个例子：
```java
name in { null,"Untitled" }
```
这将测试名称属性是否为null或等于"Untitled"。
上述描述的语法将创建List接口的一个实例。具体的子类未定义

有时您希望创建Java本地数组，例如int[]或Integer[]。OGNL支持类似于通常调用构造函数的方式创建这些数组，但允许从现有列表或数组的给定大小初始化本地数组。
```java
// 这将创建一个由三个整数1、2和3组成的新int数组。
new int[] { 1, 2, 3 }
// 要创建所有元素为null或0的数组，请使用备用大小构造函数
new int[5]
```

```java
// 创建map
#{ "foo" : "foo value", "bar" : "bar value" }
// 创建特定类型的map
#@java.util.LinkedHashMap@{ "foo" : "foo value", "bar" : "bar value" }
```

+ 投射

OGNL 提供了一种简单的方式，用于调用集合中每个元素的相同方法或提取相同属性，并将结果存储在新的集合中。我们将此称为“投射”，这源自数据库术语，用于从表中选择列的子集。例如，以下表达式：
```java
listeners.{delegate}
```

返回所有监听器委托的列表。有关 OGNL 如何将各种类型的对象视为集合的处理，请参阅强制转换部分。
在投射过程中，#this 变量引用当前迭代的元素。
```java
objects.{ #this instanceof String ? #this : #this.toString()}
```
以上代码将产生一个新的元素列表，其中包含来自对象列表的字符串值。

+ 调用构造函数

您可以像在Java中一样使用new运算符创建新对象。一个区别是，除了java.lang包中的类之外，您必须指定类的完全限定名称。

只有在默认的ClassResolver设置中才成立。通过自定义类解析器，可以将包映射到更多类似于Java的类引用的方式。有关使用ClassResolver类的详细信息，请参阅OGNL开发人员指南（例如，new java.util.ArrayList()，而不仅仅是new ArrayList()）。

OGNL使用与重载方法调用相同的过程选择要调用的正确构造函数。

+ 调用静态方法

您可以使用语法@class@method(args)调用静态方法。如果省略了类，它默认为java.lang.Math，以使调用min和max方法更容易。如果指定了类，则必须给出完全限定的名称。

如果您有一个类的实例，您希望调用其静态方法，则可以通过对象调用该方法，就像它是一个实例方法一样。

如果方法名重载，OGNL将使用与重载实例方法相同的过程选择要调用的正确静态方法。

+ 获取静态字段

您可以使用语法@class@field引用静态字段。类必须是完全限定的。

> 图10-15 Ognl官方文档

![图10-15 Ognl官方文档](../../.vuepress/public/images/book/expression/img/10-15.jpg)

> Ognl官方文档：https://commons.apache.org/dormant/commons-ognl/language-guide.html



### 10.2.2 源码解析

